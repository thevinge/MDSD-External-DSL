grammar org.xtext.mdsd.external.QuickCheckApi with org.eclipse.xtext.common.Terminals

generate quickCheckApi "http://www.xtext.org/mdsd/external/QuickCheckApi"

Builder: 
	tests+=Test+;

Test:
	"Test" name=ID definitions+=(VarDefinition)* (resetHook=ResetHook)?  requests+=(Request)+
;

ResetHook:
	"ResetHook" url=URLRef
;

VarDefinition:
	(URLDefinition | JsonDefinition | GenDefinition)
;

JsonDefinition returns VarDefinition:
	{JsonDefinition} name=ID "=" json=Json
;

URLDefinition returns VarDefinition:
	{URLDefinition} name=ID "=" url=URL
;

GenDefinition returns VarDefinition:
	{GenDefinition} name=ID "=" gen=Generator
;



Request:
    "request" name=ID method=Method url=URLRef ("Precondition:" preconditions=PreLogicExp)? 
    (params=Param)? body=Body? ("STATE:" action=Action) ("Postcondition:"postconditions=PostLogicExp)?
;


Action:
	{CreateAction} "create" value=JsonRef  | {DeleteAction} "delete" value=JsonRef  | {UpdateAction} "update" value=JsonRef  | {NoAction} "none"
;


Method:
	{GET} "GET" | {POST} "POST" | {PUT} "PUT" | {PATCH} "PATCH" | {DELETE} "DELETE"	
;

URLRef:
	URL | URLDefRef
;

URLDefRef:
	{URLDefRef} ref=[URLDefinition] ("/" extraUri=URI)? ("/@" requestID=RequestID)?
;

URL:
	{URL} protocol=Protocol "://" domain=Domain "/" (uri=URI)? ("/@" requestID=RequestID)?
;

Domain:
	host=Host (":" port=Port)? 
;

RequestID:
	name=ID
;

URI:
	name=ID("/" path+=PathPart)*	
;

PathPart:
	part=ID	
;

Host:
	hostParts+=ID ("." hostParts+=ID)* | ips+=INT ("." ips+=INT)*
;

Port:
	{Port} value=INT
;

Protocol:
	"http" | "https"	
;


Param:
	"parameters" pairs+=KVPair (";" pairs+=KVPair)*	
;

KVPair:
	key=Key "=" value=Value 
;

Value:
	ID | INT
;

Key:
	name=ID	
;

Body:
	"body" value=JsonRef
;

JsonRef:
	Json | JsonDefRef
;

JsonDefRef:
	{JsonDefRef} ref=[JsonDefinition]
;

Json:
	{Json} data=JsonObject | JsonList
	
;

JsonList returns Json:
	{JsonList} "[" jsonValues+=JsonValue ("," jsonValues+=JsonValue)* "]"
;

JsonObject returns Json:
	{JsonObject} "{" jsonPairs+=JsonPair ("," jsonPairs+=JsonPair)* "}"
;

JsonPair returns Json:
	{JsonPair} key=JsonKey ":" value=JsonValue
;

JsonKey:
	{JsonKey} value=ID
;

JsonValue returns Json:
	{StringValue} value=STRING | {IntValue} value=INT | {NestedJsonValue} value=JsonObject | {ListJsonValue} value=JsonList | {NestedJsonDef} value=[JsonDefinition] | {CustomValue} value=CustomValue
;

CustomValue:
	 GeneratedValue | {ExcludeValue} "-" | ReuseValue | IdentifierValue	
;

IdentifierValue:
	{IdentifierValue} "@id"
; 

ReuseValue:
	{ReuseValue} '^'key=[JsonKey];

GeneratedValue:
	{GenRef} '#'ref=[GenDefinition]
;


Generator:
	{Generator} "<" method=GenMethod  ">"
;

GenValue:
	{StringGenValue} value=STRING | {IntGenValue} value=INT | {NestedGen} value=Generator
;

GenMethod:
	OneOfGen | IntGen | StringGen
;

StringGen:
	{StringGen} "String" 
;

OneOfGen returns GenMethod:
	{OneOfGen} "oneOf" "[" Values+=GenValue ("," Values+=GenValue)* "]"
;

IntGen returns GenMethod:
	{IntGen} "Int" ("<" from=INT ',' to=INT ">")?
;

PreLogicExp returns Preproposition:
	PreConjunction("OR" {PreDisjunction.left=current} right=PreConjunction)*
;

PreConjunction returns Preproposition:
	Precondition ("AND" {PreConjunction.left=current} right=Precondition)*	
;

Precondition returns Preproposition:
	{ContainsCondition} notOp=NotOp? "contains" value=Json | {EmptyCondition} notOp=NotOp? "empty"
;

PostLogicExp returns Postproposition:
	PostConjunction ("OR" {PostDisjunction.left=current} right=PostConjunction)*
;

PostConjunction returns Postproposition:
	Postcondition ("AND" {PostConjunction.left=current} right=Postcondition)*	
;


Postcondition returns Postproposition:
	{BodyCondition}requestOp=RequestOp requestValue=ResponseBody | {CodeCondition}requestOp=RequestOp statusCode=StatusCode 
;

StatusCode:
	"code" code=INT
;

ResponseBody:
	{ResponseBody} "body" body=JsonRef?
;

RequestOp:
	{RequestOp} notOp=NotOp? "returns"	
;

NotOp:
	"not"	
;